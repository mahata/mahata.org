+++
date = "2017-06-14T22:11:57+09:00"
draft = true
title = "*nix が wait 絡みのデッドロックを防ぐ仕組み"

+++

引き続き「[Working With Unix Processes](https://www.amazon.co.jp/exec/obidos/ASIN/B0078VSRUE/96c11b31f45ff807-22/ref=nosim/)」を読んでいる。

サンプルで「デッドロックが起こりそう **だけど、起こらない**」コードが掲載されていた。次のスニペットは、そのサンプルを少し書き換えたものだ。

```ruby
#!/usr/bin/env ruby

# ふたつの子プロセスをつくり、すぐに殺す
2.times do
  fork do
    abort "おしまい"
  end
end

# 最初の子プロセスを待ち、その後は3秒ほど寝る
# 寝ている間にもうひとつの子プロセスも終了する
puts Process.wait
sleep 3

# もう子プロセスは終了しているので、これはデッドロックするはずでは? => 実際はしない
puts Process.wait
```

コードのコメントに書いた通りなのだが、最後の `Process.wait` はデッドロックになっても不思議ではない... けど、実際にはデッドロックにならない。

カーネルには `exit` したプロセスの情報をキューに詰めておく機構があり、親プロセスは死んだ子プロセスの順にその情報を取得できる。だから、サンプルでの最後の `Process.wait` は実際には子プロセスの終了を待つのではなく、キューから「既に死んだ」子プロセスの情報を取得している。

ただ、子プロセスが存在しない「かつ」前述のキューにもデータが存在しないとき、`Process.wait` は `Errno::ECHILD` 例外を起こす。

まあ、それはそうだよね。
